---
title: 'Service worker rendering, in the cloud and in the browser'
excerpt: 'CloudFlare Workers + Workbox = isomorphic rendering'
tags:
  - post
  - serviceworker
  - cloudflare
---

## tl;dr

This site is now rendered entirely on-demand via service workers!

The first time you visit, you'll get HTML rendered in the cloud using [CloudFlare Workers](https://workers.cloudflare.com/). For each subsequent page you visit, a local in-browser service worker generates equivalent HTML, using locally cached data.

Both service worker environments share the majority of the same [Workbox](https://developers.google.com/web/tools/workbox/) code for routing and streaming response generation.

You can see everything that changed from my previous setup in [this diff](https://github.com/jeffposnick/jeffy-info/compare/627e88f1ce0a583d08bd5a31638da1f60bec74d6...239d278c07a9fdde273e9337056a4d04dcc321f4).

## Previously, on blog infra

<a href="https://jeffy.info/">https://jeffy.info/</a> previously ran a custom [11ty](https://www.11ty.dev/) setup, with static HTML generated at build time, using [Nunjucks](https://mozilla.github.io/nunjucks/) templates and Markdown pages. (It was migrated from a long-ago [Jekyll](https://jekyllrb.com/) config.)

After your first visit, a [Workbox](https://developers.google.com/web/tools/workbox/)-powered service worker takes over, and caches all of the templates and page data. HTML for future navigations are generated by the SW, independent of the network, using the same templating logic that 11ty uses at build time.

The templates are cached independently from the page content, so you can, e.g., update the site header template, and that's the only thing that needs to be invalidated—already cached content can stay as-is.

It was served from Firebase static hosting.

This all worked well!

But, the disconnect between how 11ty and the service worker generate the HTML has bothered me. They share templates, but static HTML routing happens via file system layout, while the service worker needs its own independent routing configuration. Also, running Nunjucks inside of a service worker _works_, but it's not exactly elegant, or lightweight. And generating the site's full HTML at build time is fine for a site with a modest amount of content, but I could see it being an issue for larger sites, or for sites that rely on database or API lookups to populate their HTML.

## Service workers everywhere

I've been eyeing the advent of new cloud runtime environments that expose the [service worker](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API) API (or some modified version of it). [CloudFlare Workers](https://workers.cloudflare.com/) seems like the most mature of them, and it looks like the recently formed [Deno Company](https://deno.com/blog/the-deno-company) is [working](https://github.com/denoland/deno/issues/5957) on something similar. Running the service worker API in the cloud opens the door for truly sharing routing and HTML generation logic with the browser's service worker.

A recent [tweet](https://twitter.com/lukeed05/status/1415036180765106176) from [Luke Edwards](https://twitter.com/lukeed05) about his new, lightweight [Handlebars](https://handlebarsjs.com/)-compatible templating library, [Tempura](https://github.com/lukeed/tempura), reminded me that Luke was now working on the CloudFlare DevRel team, and I have been [intending](https://twitter.com/jeffposnick/status/1379525749514850305) to explore this space further.

Well, no time like this weekend!

### Build setup

Some of the work involved swapping out the 11ty build infrastructure in favor of a [bespoke build process](https://github.com/jeffposnick/jeffy-info/tree/239d278c07a9fdde273e9337056a4d04dcc321f4/scripts). At some point I might re-add 11ty, because I ultimately think that I just ended up recreating most of what it already does, but while noodling on this, I needed the level of control offered by generating _exactly_ the build artifacts I wanted.

The nice thing is that, for the most part, my existing posts didn't need to change—they remain Markdown documents with some [frontmatter](https://jekyllrb.com/docs/front-matter/) metadata, just like 11ty (and before that, Jekyll) expected.

### Shared service worker code

Most of the magic takes place in the [shared service worker code](https://github.com/jeffposnick/jeffy-info/blob/239d278c07a9fdde273e9337056a4d04dcc321f4/src/service-worker/common.ts), which handles routing using a [wrapper](https://github.com/jeffposnick/jeffy-info/blob/239d278c07a9fdde273e9337056a4d04dcc321f4/src/service-worker/URLPatternMatcher.ts) on top of the upcoming [`URLPattern`](https://chromestatus.com/feature/5731920199548928) API (which, [stay tuned](https://github.com/GoogleChrome/web.dev/pull/5780) to learn more about), along with some logic to handle static assets like images or JSON files.

### Streaming, sequential templates

Each matching route triggers a sequence of [Tempura templates](https://github.com/jeffposnick/jeffy-info/tree/239d278c07a9fdde273e9337056a4d04dcc321f4/site/templates), with each rendered template streaming its partial HTML immediately in environments that support constructing [`ReadableStream`s](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API/Using_readable_streams), courtesy of the [`workbox-streams` library](https://developers.google.com/web/tools/workbox/reference-docs/latest/module-workbox-streams). This initial HTML response always comes from the [first template](https://github.com/jeffposnick/jeffy-info/blob/239d278c07a9fdde273e9337056a4d04dcc321f4/site/templates/start.hbs) immediately, without blocking on any data retrieval, so you should see consistently fast renders of each page's header. What's displayed right away is roughly equivalent to what you'd see if you were using an [App Shell](https://developers.google.com/web/fundamentals/architecture/app-shell).

Unlike with an App Shell approach, it's easy to set up a completely different sequence of templates for different routes. You're not forced to always respond with a single, hardcoded placeholder HTML document.

### Different approaches to static assets

The one place where the CloudFlare and browser logic differs is the logic used to load static assets.

The CloudFlare Workers runtime supports loading static assets via a [`kv-asset-handler` helper library](https://github.com/cloudflare/kv-asset-handler).

The browser runtime relies on Workbox's caching and routing to load those assets. Most of the site's assets are [precached](https://developers.google.com/web/tools/workbox/modules/workbox-precaching), with an asset manifest generated at [build time](https://github.com/jeffposnick/jeffy-info/blob/239d278c07a9fdde273e9337056a4d04dcc321f4/scripts/utils.mjs#L97-L106). Anything precached can be loaded by the browser's service worker via Workbox's [`matchPrecache()` method](https://github.com/jeffposnick/jeffy-info/blob/239d278c07a9fdde273e9337056a4d04dcc321f4/src/service-worker/browser-sw.ts#L17-L26).

Some of the pages on this blog have images, though, and it seems a bit wasteful to precache those unconditionally. Instead, I have a [browser-only route](https://github.com/jeffposnick/jeffy-info/blob/239d278c07a9fdde273e9337056a4d04dcc321f4/src/service-worker/browser-sw.ts#L30-L35) set up to match `/images/` requests, along with a [stale-while-revalidate strategy](https://developers.google.com/web/tools/workbox/modules/workbox-strategies#stale-while-revalidate) for keeping those cached and updated.

If you're offline and visit a page that has an image you haven't previously seen, then the page's content will load, but the images won't be available. That seems like a reasonable compromise!

## What's next?

Unlike some of my [previous efforts](https://developers.google.com/web/updates/2018/05/beyond-spa) in this space, I'm pretty confident that this setup isn't _too_ out there. It seems like web developers are comfortable with embracing service workers in the cloud, and Workbox has been going strong for over six years now.

Moreover, while I implemented this architecture on blog site with Markdown files, this same approach could apply equally well to a site that relied on database or API calls to populate each page's content. The only thing that needs to change is the logic that retrieves data to populate each page's template. And because that logic only needs to be written in one place, inside the shared service worker code, you don't have to worry about it getting out of sync between the cloud and browser.

I'm excited to see if more folks use [my current setup](https://github.com/jeffposnick/jeffy-info/tree/627e88f1ce0a583d08bd5a31638da1f60bec74d6) as inspiration, and am happy to chat with anyone interested in turning this into a  reusable started kit!
